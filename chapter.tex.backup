\sEction {2 Выбор инструментов для реализации web-приложения}

\SEction{2.1 Single Page Application}

Основной задачей данного проекта является реализация web-приложения, взаимодействующее с web-сервером по протоколу SOAP. Результатом проекта должно получится приложение, которое сможет быстро и мгновенно реализовывать функциональнные операции. В настоящее время в сфере web разработки наряду с многостраничными сайтами (Multi-page Application, MPA) широкое распространение получили и одностраничные приложения (Single-page Application, SPA), формирование контента которых происходит динамически на стороне клиента. В связи с этим было решено реализовывать одностраничное приложение. На рисунках  \ref{mpa} и  \ref{spa} представлена схема работы многостраничного и одностраничного сайта соответственно.

\begin{figure}[h]
\center\includegraphics[width=0.4\textwidth]{mpa}
\caption{Архитектура Multi-page Application}\label{mpa}
\end{figure}

\begin{figure}[h]
\center\includegraphics[width=0.4\textwidth]{spa}
\caption{Архитектура Single Page Application}\label{spa}
\end{figure}

Single Page Application -- это web-приложение, размещенное на одной странице. Применяя такую технологию, можно создать сайт,  который будет представлять собой одну html-страницу, интерактивность которой обеспечивается скриптами. Работа такого web-сайт максимально полностью перенесена на сторону клиента. Сайт <<общается>> с сервером только чистыми данными, без загрузки html-контента.
 
Для того чтобы написать одностраничное приложение необходимо придерживаться определенных правил:
\begin{enumerate}
\item Все сущности приложения основаны на моделях и объектах. Внутри объектов инкапсулирована работа с DOM-элементами страницы.
\item Насколько позволяет структура хранит HTML шаблоны в скриптах
\item При любые изменения на странице динамически изменяют url.
\item Прямая загрузка любого url должна отобразить соответствующую страницу с данными.
\item Обработчик события History back, что соответствует кнопки назад в браузере, должен выполняться корректно и возвращать страницу в предыдущее состояние.
\item Кеширование моделей данных на стороне клиента.
\end{enumerate}

Если учитывать эти основные правила, в результате получится эффективное, быстрое и полнофункциональное одностраничное web-приложение.   Но как и любой продукт, приложение обладает рядом преимуществ и недостатков. Рассмотрим плюсы и минусы данного подхода и почему SPA все равно остается популярным.

К преимуществам SPA можно отнести следующее:
\begin{enumerate}
\item Работа на большом количестве устройств. Приложения на SPA отлично работают на устройствах как стационарных, так и мобильных. Персональные компьютеры, планшеты, смартфоны могут беспрепятственно работать с сайтами построенных по принципу SPA. Создав одно приложение, мы получим гораздо большую аудиторию пользователей нежели при использовании стандартного подхода.
\item  Богатый пользовательский интерфейс. Так как web-страница одна, построить функцинальный и приятный пользовательский интерфейс гораздо проще. Не так затруднительно хранить информацию о сеансе, управлять состояниями представлений и управлять анимацией.
\item Отсутствие загрузки одного и того же контента снова и снова. Если сайт использует шаблон, то вместе с основным содержанием какой-либо страницы посетитель сайта обязательно загружает разметку шаблона. Конечно, кэширование данных на данном этапе развития в web-программировании достигло высоких результатов, но если нечего кэшировать, то время  и ресурсы на это не тратятся.
\end{enumerate}

Самым главным неудобством при разработке SPA -- это работа с языком программирования JavaScript. JavaScript изначально позиционировался как простой язык программирования с Java-подобным синтасисом. Но  JavaScript не обладает статической типизацией, его объектная модель не является привычной для многих разработчиков. Отладка кода представляет собой трудный процесс. Кроме того, различные интернет-обозреватели могут по-разному интерпретировать JavaScript-код. Поэтому разработка требуемого приложения с использованием исключительно языка JavaScript является довольно трудоёмким процессом. Чтобы как-то исправить несовместимость с некоторым браузерами, приходится писать отдельный код для различных клиентов. Таким образом, размер кода возрастает, а функциональность нет. В итоге приходится основную часть времени тратить на обработку особенностей выполнения кода различными движками, а не на реализацию продукта. Частично последнюю проблему можно решить использованием специальных библиотек, примеру, библиотека jQuery.  


\SEction {2.2 JavaScript-фреймворки}

На смену библиотекам вроде jQuery в мир JavaScript приходят фреймворки, реализующие функциональную схему Model-view-controller. 

Model-view-controller (MVC) -- схема использования нескольких шаблонов проектирования, с помощью которых модель приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента таким образом, чтобы модификация одного из компонентов оказывала минимальное воздействие на остальные. Архитектура работы MVC представлена на рисунке \ref{mvc}

\begin{figure}[h]

\center\includegraphics[width=0.7\textwidth]{mvc}

\caption{Схема Model-view-controller}\label{mvc}

\end{figure}

Концепция MVC позволяет разделить данные, представление и обработку действий пользователя на три отдельных компонента:
\begin{enumerate}
\item Модель (англ. Model). Модель предоставляет знания: данные и методы работы с этими данными, реагирует на запросы, изменяя своё состояние. Не содержит информации, как эти знания можно визуализировать.
\item Представление, вид (англ. View). Отвечает за отображение информации (визуализацию). Часто в качестве представления выступает форма (окно) с графическими элементами.
\item Контроллер (англ. Controller). Обеспечивает связь между пользователем и системой: контролирует ввод данных пользователем и использует модель и представление для реализации необходимой реакции.
\end{enumerate}

Важно отметить, что как {\itshape представление}, так и {\itshape контроллер} зависят от {\itshape модели}. Однако модель не зависит ни от представления, ни от контроллера. Тем самым достигается назначение такого разделения: оно позволяет строить модель независимо от визуального представления, а также создавать несколько различных представлений для одной модели.


Преимущества фреймворков видны невооруженным глазом. Один из самых существенных является избавление от рутинного кода, который тянется от проекта к проекту. Фреймворк предоставляет разработчикам каркас будущего приложения и решение задач, встречающихся в большинстве проектов. Например, программисту не нужно думать, как принять данные от клиента и передать их на сервер, т.к. все необходимое скорей всего реализовано авторами фреймворка. Вместо этого разработчику предлагается сосредоточиться функционалом собственного приложения.

Другим немаловажным плюсом всех фреймворков является стандартизация кодирования. Если разработчик решается применять готовый каркас в своем проекте, то он должен быть готовым следовать его заповедям. Это значит, что ему нужно не полениться - один раз ознакомиться с правилами и быть спокойным, что в последствие код без проблем может дорабатываться другими разработчиками. 

Очень часто многие разработчики задают вопрос -  Чем один Javascript фреймворк лучше другого? На этот вопрос трудно ответить, ведь каждый фреймворк обладает определенным набором инструментов и имеет свой круг задач, с которыми он успешно справляется. Выбор JavaScript MVC фреймворка — тяжёлая работа. Нужно учесть много факторов, и число вариантов выбора может быть огромно. 


Для создание приложения на основе SPA необходимо отобрать несколько фреймворков, чей функционал справится с поставленной задачей, рассмотреть сильные и слабые стороны каждого и выбрать подходящий вариант.

\SEction {2.2.1 Angular}

\SEction {2.2.2 BackBone}

Приложения на Backbone не придерживаются строгой архитектуры. Основная идея, которую несёт документация: используйте инструменты этого фреймворка так, как вам хочется. Благодаря такому подходу Backbone хорош для абсолютно разных задач, и на нем очень просто начать писать приложения. Однако с другой стороны, это приводит к тому, что новички совершают ошибки в самом начале работы с ним. 

Работая с Backbone, данные представляются как Модели (Models), которые могут быть созданы, провалидированы, удалены, и сохранены на сервере. Всякий раз, когда в интерфейсе изменяется атрибуты модели, модель вызывает событие "change"; все Представления (Views), которые отображают состояние модели, могут быть уведомлены об изменении атрибутов модели, с тем чтобы они могли отреагировать соответствующим образом — например, перерисовать себя с учетом новых данных. При изменении модели представление просто обновит себя самостоятельно.

Рассмотрим поподробней сущности Backbone, их предназначение и минимальную реализацию:
\begin{enumerate}
\item Backbone.Model; Model  -- это единица данных. Отвечает за получение, отправку, хранение, валидацию и прочие манипуляции с данными какой-то сущности. Простая реализация такой единицы данных представлена на рисунке \ref{modal}.

\item Backbone.Collection; Collection -- это упорядоченный набор  моделей. Отвечает за получение и отправку данных какой-то сущности, а так же манипуляции с моделями (создание, обновление, удаление). Работает только с моделями определенного типа. Простая реализация такого списка представлена на рисунке \ref{collection}.

\item Backbone.View; View -- это представление модели или коллекций, отвечает за реализацию интерфейса. Отвечает за рендеринг модели или коллекции, работу с шаблонами, обработку событий и другое. Простая реализация представлена на рисунке \ref{view}.

\item Backbone.Router; Router предоставляет методы для маршрутизации на стороне клиента, а также связывания этих действий с событиями. Простая реализация таких методов представлена на рисунке \ref{router}.

\end{enumerate}

\begin{figure}[h]
\center\includegraphics[width=0.75\textwidth]{model}
\caption{Backbone.Model}\label{modal}
\end{figure}

\begin{figure}[h]
\center\includegraphics[width=0.75\textwidth]{collection}
\caption{Backbone.Collection}\label{collection}
\end{figure}


\begin{figure}[h]
\center\includegraphics[width=0.75\textwidth]{view}
\caption{Backbone.View}\label{view}
\end{figure}

\begin{figure}[h]
\center\includegraphics[width=0.75\textwidth]{router}
\caption{Backbone.Router}\label{router}
\end{figure}

\SEction {2.2.3 Сравнение Angular и BackBone}

Перед тем как реализовывать приложение, были тчательно изучены и опробованы оба фреймворка. Были выбраны характеристики, которые являются важными при реализации приложения, и на основе полученных данных произвели сравнение фреймворков. характеристики для сравнения:
\begin {enumerate}
\item Порог входа и документация
\item Продуктивность разработки
\item Набор функций
\item Размер 
\item Защита от утечки памяти 
\end {enumerate}

{\itshape Порог входа и документация}
Angular легко позволяет делать сложные вещи такие, как двунаправленная синхронизация. Но после освоения базовых знаний, порог обучения становится выше: открывается сложная структура с большим количеством особенностей. Чтение документации затруднено из-за специфического жаргона и малого количества примеров.

Backbone — довольно прост в освоении. Но после длительного использования вы можете обнаружить, что не хватает понимания того, как лучше структурировать код. Чтобы исправить сложившуюся ситуацию необходимо просмотрет или прочитать несколько учебников. 

{\itshape Продуктивность разработки}

Разработка с помощью Angular будет достаточно быстрой и эффективной, после того, как изучить его основные функции и принцип работы.

Backbone требует написания очень большого объёма шаблонного кода. Что оказывается прямой угрозой производительности труда и является неэффективным.

{\itshape Набор функций}

Среди основного набора функций, которым оладает схема MVC является:
\begin{enumerate}
\item Реализация паттерна <<Наблюдатель>>: объекты, изменения которых отслеживаются.
\item  Наличие автоматически изменяемых представлений
\item Представления (визуализация шаблонов), включающие другие представления.
\item Показ представлений по некоторым условиям.
\item Использование автоматически изменяемых представлений, когда наблюдаемый объект изменяется.
\end{enumerate}

Angular полный набор перечисленных функций.

Backbone, в свою очередь, иметь только реализацю паттерна <<Наблюдатель>>

{\itshape Размер и зависимости} Является важным фактором для мобильной разработки.

Angular имеет размер в 80 килобайт, однако это едиственный фреймворк, не требующий дополнительных библиотек.

Backbone считается самым маленький фреймворк, но требует как минимум две библиотеки, что увеличивает размер фреймворка до 61 килобайта.

{\itshape Защита от утечки памяти} Так же является важным фактором для длительно открытых одностраничных приложений.

С фреймворком Angular можно эффективно решать проблему с утечкой памяти, даже не обладая огромным опытом в разработке.

Что нельзя сказать о фреймворке Backbone. При недостаточных знаний эта проблема окажется глобальной.

